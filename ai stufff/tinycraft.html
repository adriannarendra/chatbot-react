<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Tinycraft — Single-file 3D (no install)</title>
    <style>
        :root {
            --bg1: #87ceeb;
            --bg2: #77a6d6;
            --panel: #0b1220;
            --muted: #eef2ff
        }

        html,
        body {
            height: 100%;
            margin: 0;
            font-family: Inter, system-ui, Segoe UI, Roboto, Arial
        }

        body {
            background: linear-gradient(180deg, var(--bg1), var(--bg2));
            overflow: hidden
        }

        #overlay {
            position: fixed;
            left: 12px;
            top: 12px;
            z-index: 20;
            color: #021013;
            background: rgba(255, 255, 255, 0.85);
            padding: 10px;
            border-radius: 8px;
            font-weight: 700
        }

        #info {
            position: fixed;
            right: 12px;
            top: 12px;
            z-index: 20;
            color: #fff;
            background: rgba(0, 0, 0, 0.35);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px
        }

        #ui {
            position: fixed;
            left: 12px;
            bottom: 12px;
            z-index: 20;
            color: #021013;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            font-size: 13px
        }

        button {
            font-weight: 700;
            padding: 6px 10px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            background: #10b981;
            color: white
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            display: block
        }

        .small {
            font-size: 12px;
            color: #334155
        }

        a.link {
            color: #0b66ff
        }
    </style>
</head>

<body>
    <div id="overlay">
        <div>Tinycraft — single-file (3D)</div>
        <div class="small">Click inside the screen to lock pointer & play</div>
    </div>
    <div id="info">
        <div id="status">Blocks: <span id="blockCount">0</span></div>
        <div class="small">Left click: destroy • Right click: place • WASD: move • Space: jump</div>
    </div>
    <div id="ui">
        <button id="resetBtn">New World</button>
        <button id="saveBtn">Save</button>
        <button id="loadBtn">Load</button>
        <span class="small" style="margin-left:10px">Difficulty: </span>
        <select id="difficulty" class="small">
            <option value="easy">Easy</option>
            <option value="normal" selected>Normal</option>
            <option value="hard">Hard</option>
        </select>
    </div>
    <div id="canvas-container"></div>

    <!-- Three.js UMD + PointerLockControls + BufferGeometryUtils -->
    <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://unpkg.com/three@0.152.2/examples/js/utils/BufferGeometryUtils.js"></script>

    <script>
        (function () {
            // Basic safety checks
            if (!window.THREE) {
                document.body.innerHTML = '<div style="padding:24px">Three.js failed to load. Please open this file in a modern browser with internet access.</div>'
                return
            }

            const container = document.getElementById('canvas-container')
            const statusEl = document.getElementById('status')
            const blockCountEl = document.getElementById('blockCount')
            const resetBtn = document.getElementById('resetBtn')
            const saveBtn = document.getElementById('saveBtn')
            const loadBtn = document.getElementById('loadBtn')
            const difficultySel = document.getElementById('difficulty')

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true })
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
            renderer.shadowMap.enabled = true
            renderer.shadowMap.type = THREE.PCFSoftShadowMap
            container.appendChild(renderer.domElement)

            const scene = new THREE.Scene()

            // Fog and sky color
            scene.fog = new THREE.FogExp2(0x87ceeb, 0.0015)

            // Camera
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000)
            camera.position.set(0, 10, 20)

            // Controls (Pointer lock + basic FPS)
            const controls = new THREE.PointerLockControls(camera, renderer.domElement)
            document.addEventListener('click', () => { try { controls.lock() } catch (e) { } })

            controls.addEventListener('lock', () => { document.getElementById('overlay').style.display = 'none' })
            controls.addEventListener('unlock', () => { document.getElementById('overlay').style.display = 'block' })

            // Lights
            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8)
            hemi.position.set(0, 200, 0)
            scene.add(hemi)

            const dir = new THREE.DirectionalLight(0xffffff, 0.8)
            dir.position.set(-50, 100, -50)
            dir.castShadow = true
            dir.shadow.mapSize.set(1024, 1024)
            dir.shadow.camera.left = -100; dir.shadow.camera.right = 100; dir.shadow.camera.top = 100; dir.shadow.camera.bottom = -100
            scene.add(dir)

            // Ground plane (invisible collision plane)
            const groundPlane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshBasicMaterial({ visible: false }))
            groundPlane.rotation.x = -Math.PI / 2
            groundPlane.position.y = -1
            scene.add(groundPlane)

            // Voxel world settings
            const CHUNK_W = 24 // x
            const CHUNK_D = 24 // z
            const MAX_H = 12   // y
            let world = {} // key 'x,y,z' -> type

            const blockTypes = [
                { id: 0, name: 'Air', color: 0x000000, solid: false },
                { id: 1, name: 'Grass', color: 0x66bb6a, solid: true },
                { id: 2, name: 'Dirt', color: 0x8b5a2b, solid: true },
                { id: 3, name: 'Stone', color: 0x9e9e9e, solid: true },
                { id: 4, name: 'Sand', color: 0xf3e9c9, solid: true },
                { id: 5, name: 'Wood', color: 0x8b5d33, solid: true },
            ]

            let meshGroup = new THREE.Group(); scene.add(meshGroup)

            // Raycaster for interactions
            const raycaster = new THREE.Raycaster()
            const mouse = new THREE.Vector2()

            let inventoryType = 1

            // Player physics
            const velocity = new THREE.Vector3()
            let canJump = false
            const move = { forward: false, back: false, left: false, right: false }

            // Utilities
            function key(x, y, z) { return x + ',' + y + ',' + z }
            function parseKey(k) { return k.split(',').map(n => Number(n)) }

            // Build terrain: simple height map
            function generateTerrain() {
                world = {}
                const difficulty = difficultySel.value
                let roughness = difficulty === 'easy' ? 0.8 : difficulty === 'normal' ? 0.6 : 0.45
                for (let x = -Math.floor(CHUNK_W / 2); x < Math.ceil(CHUNK_W / 2); x++) {
                    for (let z = -Math.floor(CHUNK_D / 2); z < Math.ceil(CHUNK_D / 2); z++) {
                        // layered height using combined sines + randomness for nicer shapes
                        const nx = x / 8, nz = z / 8
                        let h = Math.floor((Math.sin(nx * 1.3) + Math.cos(nz * 1.2)) * 2 + Math.random() * 4 * roughness + 5)
                        h = Math.max(1, Math.min(MAX_H - 1, h))
                        for (let y = 0; y <= h; y++) {
                            let t = 2 // dirt
                            if (y === h) t = 1 // grass
                            if (y < 2) t = 2
                            if (y <= 1 && Math.random() < 0.03) t = 5
                            world[key(x, y, z)] = t
                        }
                        // occasional sand near edges
                        if (Math.random() < 0.02) { world[key(x, 0, z)] = 4 }
                    }
                }
                // small caves: carve out some air
                for (let i = 0; i < 200; i++) {
                    const cx = Math.floor((Math.random() - 0.5) * CHUNK_W)
                    const cz = Math.floor((Math.random() - 0.5) * CHUNK_D)
                    const cy = Math.floor(Math.random() * MAX_H / 2)
                    const r = Math.floor(Math.random() * 3) + 1
                    for (let x = cx - r; x <= cx + r; x++)for (let y = cy - r; y <= cy + r; y++)for (let z = cz - r; z <= cz + r; z++) {
                        if (world[key(x, y, z)]) delete world[key(x, y, z)]
                    }
                }
            }

            // Build mesh from world data — merges geometries for performance
            function buildMesh() {
                if (meshGroup) { scene.remove(meshGroup); meshGroup.traverse(c => { if (c.geometry) c.geometry.dispose(); if (c.material) c.material.dispose(); }); }
                meshGroup = new THREE.Group(); scene.add(meshGroup)

                const geometriesByType = {}
                const materialByType = {}

                for (const bt of blockTypes) {
                    if (bt.id === 0) continue
                    geometriesByType[bt.id] = []
                    materialByType[bt.id] = new THREE.MeshLambertMaterial({ color: bt.color })
                }

                // create cubes only for visible faces (simple greedy not implemented, so we will add cubes but skip faces completely surrounded)
                const cubeGeom = new THREE.BoxGeometry(1, 1, 1)
                for (const k in world) {
                    const [x, y, z] = parseKey(k)
                    const id = world[k]
                    // skip internal cubes (all 6 neighbors exist)
                    const neighbors = [[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]]
                    let visible = false
                    for (const n of neighbors) { if (!world[key(x + n[0], y + n[1], z + n[2])]) { visible = true; break } }
                    if (!visible) continue
                    const geom = cubeGeom.clone()
                    geom.translate(x, y, z)
                    geometriesByType[id].push(geom)
                }

                for (const id in geometriesByType) {
                    const list = geometriesByType[id]
                    if (list.length === 0) continue
                    const merged = THREE.BufferGeometryUtils.mergeBufferGeometries(list, false)
                    const mesh = new THREE.Mesh(merged, materialByType[id])
                    mesh.castShadow = true
                    mesh.receiveShadow = true
                    meshGroup.add(mesh)
                }

                blockCountEl.textContent = Object.keys(world).length
            }

            // Place or remove a block at target position
            function placeBlock(x, y, z, type) {
                if (y < 0 || y >= MAX_H) return
                world[key(x, y, z)] = type
                buildMesh()
            }
            function removeBlock(x, y, z) { delete world[key(x, y, z)]; buildMesh() }

            // Convert screen center to ray for interactions
            function getTargetBlock(intersectDistance) {
                // cast a ray from camera forward
                raycaster.setFromCamera({ x: 0, y: 0 }, camera)
                const intersects = raycaster.intersectObjects(meshGroup.children, true)
                if (intersects.length === 0) return null
                const hit = intersects[0]
                const point = hit.point.clone()
                const normal = hit.face.normal.clone()
                // world block position
                const px = Math.round(point.x - normal.x * 0.5)
                const py = Math.round(point.y - normal.y * 0.5)
                const pz = Math.round(point.z - normal.z * 0.5)
                return { hit, point, normal, pos: { x: px, y: py, z: pz } }
            }

            // Interaction handlers
            window.addEventListener('mousedown', (e) => {
                if (!controls.isLocked) return
                e.preventDefault()
                if (e.button === 0) { // left = destroy
                    const data = getTargetBlock()
                    if (!data) return
                    const { x, y, z } = data.pos
                    removeBlock(x, y, z)
                } else if (e.button === 2) { // right = place
                    const data = getTargetBlock()
                    if (!data) return
                    const { point, normal } = data
                    const placeX = Math.round(point.x + normal.x * 0.5)
                    const placeY = Math.round(point.y + normal.y * 0.5)
                    const placeZ = Math.round(point.z + normal.z * 0.5)
                    placeBlock(placeX, placeY, placeZ, inventoryType)
                }
            })
            // prevent context menu
            window.addEventListener('contextmenu', e => { if (controls.isLocked) e.preventDefault() })

            // Movement controls
            document.addEventListener('keydown', (e) => {
                if (e.code === 'KeyW' || e.code === 'ArrowUp') move.forward = true
                if (e.code === 'KeyS' || e.code === 'ArrowDown') move.back = true
                if (e.code === 'KeyA' || e.code === 'ArrowLeft') move.left = true
                if (e.code === 'KeyD' || e.code === 'ArrowRight') move.right = true
                if (e.code === 'Space' && canJump) { velocity.y = 8; canJump = false }
            })
            document.addEventListener('keyup', (e) => {
                if (e.code === 'KeyW' || e.code === 'ArrowUp') move.forward = false
                if (e.code === 'KeyS' || e.code === 'ArrowDown') move.back = false
                if (e.code === 'KeyA' || e.code === 'ArrowLeft') move.left = false
                if (e.code === 'KeyD' || e.code === 'ArrowRight') move.right = false
            })

            // Simple collision detection: check if player's feet would collide with a solid block
            function isSolidAt(x, y, z) { return !!world[key(Math.floor(x + 0.0001), Math.floor(y + 0.0001), Math.floor(z + 0.0001))] }

            // Main loop
            let prevTime = performance.now()
            function animate() {
                requestAnimationFrame(animate)
                const time = performance.now()
                const delta = (time - prevTime) / 1000
                prevTime = time

                // update renderer size
                const w = container.clientWidth, h = container.clientHeight
                if (renderer.domElement.width !== w || renderer.domElement.height !== h) { renderer.setSize(w, h); camera.aspect = w / h; camera.updateProjectionMatrix() }

                if (controls.isLocked) {
                    // basic movement relative to camera direction
                    const speed = 6
                    const dir = new THREE.Vector3()
                    const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize()
                    const right = new THREE.Vector3(); right.crossVectors(new THREE.Vector3(0, 1, 0), forward).normalize()
                    if (move.forward) dir.add(forward)
                    if (move.back) dir.sub(forward)
                    if (move.left) dir.add(right)
                    if (move.right) dir.sub(right)
                    dir.normalize()
                    // apply horizontal movement
                    if (dir.length() > 0) { velocity.x = dir.x * speed; velocity.z = dir.z * speed } else { velocity.x = THREE.MathUtils.damp(velocity.x, 0, 4, delta); velocity.z = THREE.MathUtils.damp(velocity.z, 0, 4, delta) }

                    // gravity
                    velocity.y -= 20 * delta

                    // move camera position
                    const oldPos = controls.getObject().position.clone()
                    controls.getObject().position.x += velocity.x * delta
                    controls.getObject().position.y += velocity.y * delta
                    controls.getObject().position.z += velocity.z * delta

                    // collision with ground
                    if (controls.getObject().position.y < -1) { controls.getObject().position.y = 10; velocity.y = 0 }

                    // simple foot collision to stand on blocks
                    const feetX = controls.getObject().position.x
                    const feetY = controls.getObject().position.y - 1.6
                    const feetZ = controls.getObject().position.z
                    const below = Math.floor(feetY)
                    if (isSolidAt(feetX, below, feetZ)) {
                        controls.getObject().position.y = below + 1.9
                        velocity.y = 0
                        canJump = true
                    }
                }

                renderer.render(scene, camera)
            }

            // UI handlers
            resetBtn.addEventListener('click', () => { generateTerrain(); buildMesh(); controls.getObject().position.set(0, 10, 0) })
            difficultySel.addEventListener('change', () => { generateTerrain(); buildMesh() })

            saveBtn.addEventListener('click', () => {
                const data = { world, difficulty: difficultySel.value }
                const s = JSON.stringify(data)
                try { localStorage.setItem('tinycraft_save', s); alert('World saved to browser storage') } catch (e) { alert('Save failed: ' + e.message) }
            })
            loadBtn.addEventListener('click', () => {
                try { const s = localStorage.getItem('tinycraft_save'); if (!s) { alert('No save found'); return } const d = JSON.parse(s); world = d.world || {}; difficultySel.value = d.difficulty || 'normal'; buildMesh(); alert('Loaded') } catch (e) { alert('Load failed: ' + e.message) }
            })

            // initial start
            generateTerrain(); buildMesh()

            // place some test objects: a simple tree
            function addTestTree(x, z) {
                let h = 4
                for (let y = 1; y <= h; y++) placeBlock(x, y, z, 5)
                for (let dx = -2; dx <= 2; dx++)for (let dz = -2; dz <= 2; dz++) {
                    const yy = h + Math.floor(Math.abs(dx) + Math.abs(dz)) % 2
                    placeBlock(x + dx, yy, z + dz, 1)
                }
            }
            addTestTree(2, 2)
            addTestTree(-4, -3)

            // set initial player position
            controls.getObject().position.set(0, 12, 0)
            scene.add(controls.getObject())

            // ensure renderer fits window
            function onResize() { renderer.setSize(container.clientWidth, container.clientHeight); camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix() }
            window.addEventListener('resize', onResize)
            onResize()

            // safety: prevent runaway memory - rebuild once per second at most
            let lastBuild = 0
            function placeBlock(x, y, z, type) { if (y < -10 || y > MAX_H + 10) return; world[key(x, y, z)] = type; const now = performance.now(); if (now - lastBuild > 300) { lastBuild = now; buildMesh() } }
            function removeBlock(x, y, z) { delete world[key(x, y, z)]; const now = performance.now(); if (now - lastBuild > 300) { lastBuild = now; buildMesh() } }

            // Expose simple console helpers for debugging (optional)
            window.tinycraft = { world, rebuild: buildMesh, place: placeBlock, remove: removeBlock }

            animate()

        })()
    </script>
</body>

</html>